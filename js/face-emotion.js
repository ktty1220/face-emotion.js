// Generated by CoffeeScript 1.6.3
/*!
* face-emotion.js v0.1.0
*
* https://github.com/ktty1220/face-emotion.js
*
* Copyright (c) 2013 ktty1220 ktty1220@gmail.com
* Licensed under the MIT license
*/


(function() {
  'use strict';
  var Angry, Eye, EyeBrow, FaceEmotion, FaceParts, Mouth, Tear, commonPrefix, effectStyleAdded, util, _ref, _ref1, _ref2, _ref3, _ref4,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  commonPrefix = 'face-emotion-';

  effectStyleAdded = false;

  util = {
    /**
    * ベンダープレフィックスを付加したプロパティの配列を返す
    *
    * @param prop CSSプロパティ名
    * @return ベンダープレフィックスを付加したプロパティの配列
    */

    venderPrefix: function(prop) {
      var initCapPrefix, result, vp, _i, _len, _ref;
      result = [prop];
      initCapPrefix = "" + (prop.substr(0, 1).toUpperCase()) + (prop.substr(1));
      _ref = ['ms', 'Webkit', 'Moz', 'O'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        vp = _ref[_i];
        result.push("" + vp + initCapPrefix);
      }
      return result;
    },
    /**
    * 4辺の値が同じborder-radiusプロパティを作成
    *
    * @param prop 丸角の値
    * @return 4辺のプロパティと値の連想配列
    */

    borderRadius: function(value) {
      return {
        borderTopLeftRadius: value,
        borderTopRightRadius: value,
        borderBottomRightRadius: value,
        borderBottomLeftRadius: value
      };
    },
    /**
    * border-widthをまとめて指定
    *
    * @param prop 各borderの値(CSSでの定義と同仕様)
    * @return 4辺のプロパティと値の連想配列
    */

    borderWidth: function(top, right, bottom, left) {
      var _ref;
      return {
        borderTopWidth: top,
        borderRightWidth: right != null ? right : top,
        borderBottomWidth: bottom != null ? bottom : top,
        borderLeftWidth: (_ref = left != null ? left : right) != null ? _ref : top
      };
    },
    /**
    * 小数を含む演算は途中から誤差が発生してくるので自力で計算(小数第2位までの計算限定)
    *
    * @param value1 値1
    * @param value2 値2
    * @return 値1 + 値2
    */

    sum: function(value1, value2) {
      /* 100倍して整数にしてから加算*/

      var n, sign;
      n = Math.round((value1 * 100) + (value2 * 100));
      /* 加算後の値の正負を保存*/

      sign = n < 0 ? '-' : '';
      /* 文字列の段階で小数点を後ろから3文字目に挿入して数値化*/

      return parseFloat(("" + sign + "00" + (Math.abs(n))).replace(/(..)$/, '.$1'));
    },
    /**
    * 文字列を含むCSSプロパティから数字部分だけ取得
    *
    * @param prop CSSプロパティの値
    * @return 数字部分(数値型)
    */

    styleNumValue: function(prop) {
      var _ref, _ref1;
      return parseFloat((_ref = ((_ref1 = ("" + prop).match(/(-?[\d\.]+)/)) != null ? _ref1 : [])[1]) != null ? _ref : '0');
    },
    /**
    * キャメルケースの文字列を展開
    *
    * @param str キャメルケースの文字列
    * @return 展開後の文字列
    */

    caseConv: function(str) {
      return str.replace(/[A-Z]/g, function(m) {
        return "-" + (m.toLowerCase());
      });
    },
    /**
    * 短縮したCSSセレクタ名を展開
    *
    * @param str 短縮状態のCSSセレクタ名
    * @return 展開後のCSSセレクタ名
    */

    expandSelector: function(prefix, str) {
      var sarray, t, tmp, _i, _len;
      if (str == null) {
        str = '';
      }
      /* ':b' -> ':before', ':a' -> ':after' & カンマ区切りで分割*/

      tmp = str.replace(/:a/g, ':after').replace(/:b/g, ':before').split(',');
      /* 分割した各セレクタにプレフィックスを付加*/

      sarray = [];
      for (_i = 0, _len = tmp.length; _i < _len; _i++) {
        t = tmp[_i];
        if (t.length > 0 && t.substr(0, 1) !== ':') {
          t = "-" + t;
        }
        sarray.push("." + commonPrefix + prefix + t);
      }
      /* またつなげる*/

      return sarray.join(",\n");
    },
    /**
    * エフェクト系のスタイルをDOMに追加
    *
    * @param effects エフェクトスタイル設定
    */

    addEffectStyle: function(effects) {
      /* すでに追加済なら何もしない*/

      var cc, head, info, prop, rule, rules, sel, sty, style, type;
      if (effectStyleAdded) {
        return;
      }
      rule = '';
      /* 短縮表記のオブジェクトをスタイルシートに書き込む文字列として展開*/

      for (type in effects) {
        info = effects[type];
        for (sel in info) {
          sty = info[sel];
          rule += "" + (util.expandSelector(type, sel)) + " {\n";
          for (cc in sty) {
            prop = sty[cc];
            if (typeof prop === 'number') {
              prop += 'px';
            }
            rule += "  " + (util.caseConv(cc)) + ": " + prop + ";\n";
          }
          rule += "}\n";
        }
      }
      /* DOMにstyleタグを追加して書き込み*/

      head = document.getElementsByTagName('head')[0];
      style = document.createElement('style');
      rules = document.createTextNode(rule);
      style.type = 'text/css';
      if (style.styleSheet) {
        style.styleSheet.cssText = rules.nodeValue;
      } else {
        style.appendChild(rules);
      }
      head.appendChild(style);
      return effectStyleAdded = true;
    }
  };

  /**
  * 各パーツのベースとなるクラス
  *
  * @class FaceParts
  */


  FaceParts = (function() {
    /* 全パーツ共通CSSプロパティ*/

    FaceParts.prototype.commonCss = {
      position: 'absolute',
      background: 'transparent',
      borderStyle: 'solid',
      borderColor: '#000',
      height: 0,
      zIndex: '10'
    };

    /**
    * コンストラクタ
    *
    * @param opt オプション(FaceEmotion()呼び出し時に渡されたものがそのまま入る)
    * @param pos パーツの左右の識別子('left' or 'right')
    */


    function FaceParts(opt, pos) {
      this.opt = opt;
      this.pos = pos;
      this.setStyle = __bind(this.setStyle, this);
      this.applyCss = __bind(this.applyCss, this);
      this.set = __bind(this.set, this);
      this.abort = __bind(this.abort, this);
      this.progress = __bind(this.progress, this);
      /* 継承先の初期処理*/

      this.init();
      /* エレメントを作成してCSS適用*/

      this.el = document.createElement('div');
      if (this.pos === 'effect') {
        this.el.className = "" + commonPrefix + "effect " + commonPrefix + this.name;
      } else {
        this.el.className = "" + commonPrefix + "parts " + commonPrefix + this.name;
        this.setStyle(this.commonCss);
        this.setStyle(this.css);
      }
      /* 目などの対になるパーツの傾き方向*/

      this.deg = this.pos === 'left' ? -1 : this.pos === 'right' ? 1 : 0;
      /* 初期状態位置*/

      this.cur = 100;
      /* アニメーションのタイマー*/

      this.timer = null;
    }

    /**
    * パーツの状態変化を1ステップ進める
    *
    * @param animate true: アニメーションさせる(即時反映), false: 内部CSSプロパティだけ更新
    */


    FaceParts.prototype.progress = function(animate) {
      var state, _ref;
      if (animate == null) {
        animate = true;
      }
      state = (_ref = this.calc()) != null ? _ref : {};
      this.applyCss(state);
      if (animate) {
        this.setStyle(state);
      }
      return this.cur += this.step;
    };

    /**
    * アニメーションを中断する
    */


    FaceParts.prototype.abort = function() {
      if (this.timer != null) {
        clearInterval(this.timer);
        return this.timer = null;
      }
    };

    /**
    * パーツの状態を変化させる
    *
    * @param value 変更させる状態位置
    * @param options オプション
    * @param callback 変化完了後に呼び出されるコールバック関数
    */


    FaceParts.prototype.set = function(value, options, callback) {
      var count, i, range, _i,
        _this = this;
      if (value == null) {
        value = 0;
      }
      if (options == null) {
        options = {};
      }
      if (this.effect != null) {
        this.effect.set(value, options);
      }
      this.goto = value;
      /* 100や-100を超えてたら補正*/

      this.goto = this.goto > 100 ? 100 : this.goto < -100 ? -100 : this.goto;
      /* -100～100だと管理が面倒なので0～200にする*/

      this.goto += 100;
      /* 現在の状態からプラス方向に進むかマイナス方向に進むかの識別値*/

      this.step = this.goto > this.cur ? 1 : this.goto < this.cur ? -1 : 0;
      /* マイナス方向に進む場合は各状態値の判定ボーダーを1つずらす(そうしないと計算が狂ってくる)*/

      this.adjust = this.step === -1 ? 1 : 0;
      count = 0;
      range = Math.abs(this.goto - this.cur);
      if (options.animate) {
        /* アニメーションの場合はタイマー起動*/

        return this.timer = setInterval(function() {
          _this.progress(true);
          if (++count >= range) {
            _this.abort();
            return typeof callback === "function" ? callback() : void 0;
          }
        }, options.speed);
      } else {
        /* 内部CSSプロパティ変更のみ*/

        for (i = _i = 0; 0 <= range ? _i < range : _i > range; i = 0 <= range ? ++_i : --_i) {
          this.progress(false);
        }
        this.setStyle(this.css);
        return typeof callback === "function" ? callback() : void 0;
      }
    };

    /**
    * 内部CSSプロパティ更新
    *
    * @param style CSSプロパティの連想配列
    */


    FaceParts.prototype.applyCss = function(styles) {
      var cc, prop, _results;
      if (styles == null) {
        styles = {};
      }
      _results = [];
      for (cc in styles) {
        prop = styles[cc];
        _results.push(this.css[cc] = prop);
      }
      return _results;
    };

    /**
    * エレメントのCSSを更新
    *
    * @param style CSSプロパティの連想配列
    */


    FaceParts.prototype.setStyle = function(styles) {
      var cc, prop, _results;
      if (styles == null) {
        styles = {};
      }
      _results = [];
      for (cc in styles) {
        prop = styles[cc];
        /* 数字なら'px'を付加*/

        if (typeof prop === 'number') {
          prop += 'px';
        }
        _results.push(this.el.style[cc] = prop);
      }
      return _results;
    };

    return FaceParts;

  })();

  /**
  * 眉毛パーツ
  *
  * @class EyeBrow
  */


  EyeBrow = (function(_super) {
    __extends(EyeBrow, _super);

    function EyeBrow() {
      this.calc = __bind(this.calc, this);
      _ref = EyeBrow.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /**
    * 初期処理(親クラスのコンストラクタから呼ばれる)
    */


    EyeBrow.prototype.init = function() {
      /* 左右の指定がなければエラー*/

      var tf, _i, _len, _ref1, _results;
      if (!/^(right|left)$/.test(this.pos)) {
        throw new Error("invalid Eye position: " + this.pos);
      }
      /* エレメントのクラス名に入れるパーツ名*/

      this.name = "eyebrow-" + this.pos;
      /* パーツ独自のCSS*/

      this.css = {
        top: this.opt.size / 200 * 45,
        width: this.opt.size / 10 * 2,
        height: 0,
        borderTopWidth: this.opt.size / 200 * 5,
        borderBottomWidth: this.opt.size / 200 * 5
      };
      this.css[this.pos] = this.opt.size / 10 * 2;
      _ref1 = util.venderPrefix('transform');
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tf = _ref1[_i];
        _results.push(this.css[tf] = 'rotate(0deg)');
      }
      return _results;
    };

    /**
    * 状態位置に対するCSSプロパティの算出
    *
    * @return 算出したCSSプロパティ
    */


    EyeBrow.prototype.calc = function() {
      var tf, tmp, tr, _i, _len, _ref1;
      tr = util.sum(util.styleNumValue(this.css.transform), -0.3 * this.step * this.deg);
      tmp = {};
      _ref1 = util.venderPrefix('transform');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tf = _ref1[_i];
        tmp[tf] = "rotate(" + tr + "deg)";
      }
      return tmp;
    };

    return EyeBrow;

  })(FaceParts);

  /**
  * 目パーツ
  *
  * @class EyeBrow
  */


  Eye = (function(_super) {
    __extends(Eye, _super);

    function Eye() {
      this.calc = __bind(this.calc, this);
      _ref1 = Eye.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    /**
    * 初期処理(親クラスのコンストラクタから呼ばれる)
    */


    Eye.prototype.init = function() {
      /* 左右の指定がなければエラー*/

      var cc, prop, tf, _i, _len, _ref2, _ref3, _ref4, _results;
      if (!/^(right|left)$/.test(this.pos)) {
        throw new Error("invalid Eye position: " + this.pos);
      }
      /* エレメントのクラス名に入れるパーツ名*/

      this.name = "eye-" + this.pos;
      /* パーツ独自のCSS*/

      this.css = {
        top: this.opt.size / 20 * 7,
        width: this.opt.size / 20 * 3,
        height: 1,
        backgroundColor: '#000',
        borderTopColor: '#000',
        borderBottomColor: '#000'
      };
      this.css[this.pos] = this.opt.size / 20 * 5;
      _ref2 = util.venderPrefix('transform');
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        tf = _ref2[_i];
        this.css[tf] = 'rotate(0deg)';
      }
      _ref3 = util.borderRadius('50%');
      for (cc in _ref3) {
        prop = _ref3[cc];
        this.css[cc] = prop;
      }
      _ref4 = util.borderWidth(this.opt.size / 200 * 15, 0);
      _results = [];
      for (cc in _ref4) {
        prop = _ref4[cc];
        _results.push(this.css[cc] = prop);
      }
      return _results;
    };

    /**
    * 状態位置に対するCSSプロパティの算出
    *
    * @return 算出したCSSプロパティ
    */


    Eye.prototype.calc = function() {
      var br, tf, tmp, tr, _i, _len, _ref2;
      tmp = {};
      switch (true) {
        case this.cur < 50 + this.adjust:
          /* < 50 (実質 -50～-100)*/

          tmp.top = util.sum(this.css.top, 0.1 * this.step);
          tmp.height = util.sum(this.css.height, -0.3 * this.step);
          tmp[this.pos] = util.sum(this.css[this.pos], -0.05 * this.step);
          tr = util.sum(util.styleNumValue(this.css.transform), -0.4 * this.step * this.deg);
          _ref2 = util.venderPrefix('transform');
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            tf = _ref2[_i];
            tmp[tf] = "rotate(" + tr + "deg)";
          }
          break;
        case this.cur < 100 + this.adjust:
          /* < 100 (実質 0～-50)*/

          if (this.cur === 50 + this.adjust) {
            if (this.step === 1) {
              tmp.borderTopColor = tmp.backgroundColor = '#000';
              tmp.borderTopLeftRadius = tmp.borderTopRightRadius = '30%';
              br = 30.4;
            } else {
              tmp.borderTopColor = tmp.backgroundColor = 'transparent';
              tmp.borderTopLeftRadius = tmp.borderTopRightRadius = '0%';
              br = 0;
            }
          } else {
            br = util.sum(util.styleNumValue(this.css.borderTopLeftRadius), 0.4 * this.step);
          }
          tmp.borderTopLeftRadius = tmp.borderTopRightRadius = "" + br + "%";
          tmp.borderTopWidth = util.sum(this.css.borderTopWidth, 0.3 * this.step);
          tmp.borderBottomWidth = util.sum(this.css.borderBottomWidth, 0.05 * this.step);
          break;
        case this.cur < 150 + this.adjust:
          /* < 150 (実質 50～0)*/

          tmp.borderTopWidth = util.sum(this.css.borderTopWidth, -0.05 * this.step);
          tmp.borderBottomWidth = util.sum(this.css.borderBottomWidth, -0.3 * this.step);
          br = util.sum(util.styleNumValue(this.css.borderBottomLeftRadius), -0.25 * this.step);
          tmp.borderBottomLeftRadius = tmp.borderBottomRightRadius = "" + br + "%";
          break;
        default:
          /* < 200 (実質 100～50)*/

          if (this.cur === 150 + this.adjust) {
            if (this.step === 1) {
              tmp.borderBottomColor = tmp.backgroundColor = 'transparent';
              tmp.borderBottomLeftRadius = tmp.borderBottomRightRadius = tmp.height = 0;
            } else {
              tmp.borderBottomColor = tmp.backgroundColor = '#000';
              tmp.borderBottomLeftRadius = tmp.borderBottomRightRadius = '37.5%';
            }
          }
          tmp.height = util.sum(this.css.height, 0.5 * this.step);
      }
      return tmp;
    };

    return Eye;

  })(FaceParts);

  /**
  * 口パーツ
  *
  * @class Mouth
  */


  Mouth = (function(_super) {
    __extends(Mouth, _super);

    function Mouth() {
      this.calc = __bind(this.calc, this);
      _ref2 = Mouth.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    /* エレメントのクラス名に入れるパーツ名*/


    Mouth.prototype.name = 'mouth';

    /**
    * 初期処理(親クラスのコンストラクタから呼ばれる)
    */


    Mouth.prototype.init = function() {
      /* パーツ独自のCSS*/

      var cc, prop, _ref3, _ref4, _results;
      this.css = {
        top: this.opt.size / 10 * 7,
        left: this.opt.size / 10 * 3,
        width: this.opt.size / 10 * 4,
        height: 0
      };
      _ref3 = util.borderRadius('0%');
      for (cc in _ref3) {
        prop = _ref3[cc];
        this.css[cc] = prop;
      }
      _ref4 = util.borderWidth(this.opt.size / 20, 0, 0);
      _results = [];
      for (cc in _ref4) {
        prop = _ref4[cc];
        _results.push(this.css[cc] = prop);
      }
      return _results;
    };

    /**
    * 状態位置に対するCSSプロパティの算出
    *
    * @return 算出したCSSプロパティ
    */


    Mouth.prototype.calc = function() {
      var br, tmp;
      switch (true) {
        case this.cur < 50 + this.adjust:
          /* < 50 (実質 -50～-100)*/

          tmp = {
            top: util.sum(this.css.top, 0.3 * this.step),
            borderTopWidth: util.sum(this.css.borderTopWidth, -0.8 * this.step)
          };
          break;
        case this.cur < 100 + this.adjust:
          /* < 100 (実質 0～-50)*/

          tmp = {
            top: util.sum(this.css.top, 0.1 * this.step),
            left: util.sum(this.css.left, 0.2 * this.step),
            width: util.sum(this.css.width, -0.4 * this.step),
            height: util.sum(this.css.height, -1.5 * this.step)
          };
          br = util.sum(util.styleNumValue(this.css.borderTopLeftRadius), -1 * this.step);
          tmp.borderTopLeftRadius = tmp.borderTopRightRadius = "" + br + "%";
          break;
        case this.cur < 150 + this.adjust:
          /* < 150 (実質 50～0)*/

          tmp = {
            top: util.sum(this.css.top, -2 * this.step),
            left: util.sum(this.css.left, -0.4 * this.step),
            width: util.sum(this.css.width, 0.8 * this.step),
            height: util.sum(this.css.height, 2.4 * this.step)
          };
          br = util.sum(util.styleNumValue(this.css.borderBottomLeftRadius), 1 * this.step);
          tmp.borderBottomLeftRadius = tmp.borderBottomRightRadius = "" + br + "%";
          if (this.cur === 100 + this.adjust) {
            if (this.goto > 100 + this.adjust) {
              tmp.borderTopWidth = 0;
              tmp.borderBottomWidth = this.opt.size / 20;
            } else {
              tmp.borderTopWidth = this.opt.size / 20;
              tmp.borderBottomWidth = 0;
            }
          }
          break;
        default:
          /* < 200 (実質 100～50)*/

          tmp = {
            top: util.sum(this.css.top, -0.5 * this.step),
            borderBottomWidth: util.sum(this.css.borderBottomWidth, 1 * this.step)
          };
      }
      return tmp;
    };

    return Mouth;

  })(FaceParts);

  /**
  * 涙パーツ
  *
  * @class Tear
  */


  Tear = (function(_super) {
    __extends(Tear, _super);

    function Tear() {
      this.calc = __bind(this.calc, this);
      _ref3 = Tear.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    /* エレメントのクラス名に入れるパーツ名*/


    Tear.prototype.name = 'tear';

    /**
    * 初期処理(親クラスのコンストラクタから呼ばれる)
    */


    Tear.prototype.init = function() {
      this.css = {
        top: util.sum(this.opt.size / 200 * 86, 0),
        opacity: '0'
      };
      return this.drop = util.sum(this.opt.size / 200 * -0.36, 0);
    };

    /**
    * 状態位置に対するCSSプロパティの算出
    *
    * @return 算出したCSSプロパティ
    */


    Tear.prototype.calc = function() {
      if (this.cur > 49 + this.adjust) {
        return {
          opacity: '0'
        };
      }
      return {
        top: util.sum(this.css.top, this.drop * this.step),
        opacity: '1'
      };
    };

    return Tear;

  })(FaceParts);

  /**
  * 怒マークパーツ
  *
  * @class Angry
  */


  Angry = (function(_super) {
    __extends(Angry, _super);

    function Angry() {
      this.calc = __bind(this.calc, this);
      _ref4 = Angry.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    /* エレメントのクラス名に入れるパーツ名*/


    Angry.prototype.name = 'angry';

    /**
    * 初期処理(親クラスのコンストラクタから呼ばれる)
    */


    Angry.prototype.init = function() {
      return this.css = {
        opacity: '0'
      };
    };

    /**
    * 状態位置に対するCSSプロパティの算出
    *
    * @return 算出したCSSプロパティ
    */


    Angry.prototype.calc = function() {
      if (this.cur < 150 + this.adjust) {
        return {};
      }
      return {
        opacity: "" + (util.sum(util.styleNumValue(this.css.opacity), 0.02 * this.step))
      };
    };

    return Angry;

  })(FaceParts);

  /**
  * 顔パーツ(本体)
  *
  * @class FaceEmotion
  */


  FaceEmotion = (function() {
    /**
    * コンストラクタ
    *
    * @param id パーツを設置するエレメントのID
    * @param options オプション
    */

    function FaceEmotion(id, options) {
      var c, cc, e, effectNum, effects, n, p, prop, styles, _i, _len, _ref5, _ref6, _ref7, _ref8;
      if (options == null) {
        options = {};
      }
      this.set = __bind(this.set, this);
      this.state = __bind(this.state, this);
      /* 設置先エレメント取得*/

      this.el = document.getElementById(id);
      if (!this.el) {
        throw new Error("no such element id: " + id);
      }
      /* オプションデフォルト値*/

      if (options.size == null) {
        options.size = 200;
      }
      /* 怒マークや涙などのエフェクトスタイル(短縮表記)*/

      effectNum = {
        tear: {
          size: options.size / 200 * 12,
          min: options.size / 200
        },
        angry: {
          size: options.size / 20,
          border: options.size / 200 * 3,
          radius: 3
        }
      };
      effects = {
        tear: {
          '': {
            position: 'absolute',
            opacity: '0',
            MsFilter: '"alpha(opacity=0)"',
            zIndex: '5',
            height: effectNum.tear.size,
            left: effectNum.tear.min * 60
          },
          ':b,:a': {
            content: "''",
            position: 'absolute'
          },
          ':b': {
            top: effectNum.tear.min * -4,
            left: effectNum.tear.min * 1.8,
            borderStyle: 'solid',
            borderColor: 'transparent',
            borderBottomColor: '#7ef',
            borderWidth: "0px " + (effectNum.tear.min * 4) + "px " + (effectNum.tear.min * 8) + "px"
          },
          ':a': {
            height: effectNum.tear.size,
            width: effectNum.tear.size,
            top: 2,
            left: 0,
            background: '#7ef',
            borderRadius: '50%'
          }
        },
        angry: {
          '': {
            height: effectNum.angry.size,
            position: 'absolute',
            opacity: '0',
            MsFilter: '"alpha(opacity=0)"',
            zIndex: '5',
            top: effectNum.angry.size * 6,
            right: effectNum.angry.size * 4
          },
          'top,bottom': {
            position: 'relative'
          },
          'top:b,top:a,bottom:b,bottom:a': {
            content: "''",
            position: 'absolute',
            width: effectNum.angry.size / 10 * 4,
            height: effectNum.angry.size / 10 * 4,
            borderStyle: 'solid',
            borderColor: '#f44',
            borderWidth: 0
          },
          'top:b,top:a': {
            top: 0,
            borderBottomWidth: effectNum.angry.border
          },
          'bottom:b,bottom:a': {
            top: effectNum.angry.size,
            borderTopWidth: effectNum.angry.border
          },
          'top:b,bottom:b': {
            left: 0,
            borderRightWidth: effectNum.angry.border
          },
          'top:a,bottom:a': {
            left: effectNum.angry.size,
            borderLeftWidth: effectNum.angry.border
          },
          'top:b': {
            borderBottomRightRadius: effectNum.angry.radius
          },
          'top:a': {
            borderBottomLeftRadius: effectNum.angry.radius
          },
          'bottom:b': {
            borderTopRightRadius: effectNum.angry.radius
          },
          'bottom:a': {
            borderTopLeftRadius: effectNum.angry.radius
          }
        }
      };
      /* 擬似属性を含むスタイルはJavaScriptでセットできないようなのでDOMにstyleタグを追加してCSSとして書き込み*/

      util.addEffectStyle(effects);
      /* 輪郭エレメント作成*/

      this.outline = document.createElement('div');
      this.outline.className = "" + commonPrefix + "outline";
      styles = {
        background: '#fff',
        border: 'solid 4px #000',
        width: options.size,
        height: options.size,
        borderRadius: '50%',
        position: 'relative'
      };
      for (cc in styles) {
        prop = styles[cc];
        if (typeof prop === 'number') {
          prop += 'px';
        }
        this.outline.style[cc] = prop;
      }
      /* 各パーツ作成*/

      this.parts = {
        eyeBrowLeft: {
          key: 'eyebrow',
          obj: new EyeBrow(options, 'left')
        },
        eyeBrowRight: {
          key: 'eyebrow',
          obj: new EyeBrow(options, 'right')
        },
        eyeLeft: {
          key: 'eye',
          obj: new Eye(options, 'left')
        },
        eyeRight: {
          key: 'eye',
          obj: new Eye(options, 'right')
        },
        mouth: {
          key: 'mouth',
          obj: new Mouth(options)
        }
      };
      /* 顔パーツ設置*/

      _ref5 = this.parts;
      for (n in _ref5) {
        p = _ref5[n];
        this.outline.appendChild(p.obj.el);
      }
      /* 涙*/

      if ((_ref6 = options.effect) != null ? _ref6.tear : void 0) {
        this.parts.tear = {
          obj: new Tear(options, 'effect')
        };
        this.outline.appendChild(this.parts.tear.obj.el);
        /* 左目に連動させる*/

        this.parts.eyeLeft.obj.effect = this.parts.tear.obj;
      }
      /* 怒マーク*/

      if ((_ref7 = options.effect) != null ? _ref7.angry : void 0) {
        this.parts.angry = {
          obj: new Angry(options, 'effect')
        };
        _ref8 = ['top', 'bottom'];
        for (_i = 0, _len = _ref8.length; _i < _len; _i++) {
          c = _ref8[_i];
          e = document.createElement('div');
          e.className = "" + commonPrefix + "effect " + commonPrefix + "angry-" + c;
          this.parts.angry.obj.el.appendChild(e);
        }
        this.outline.appendChild(this.parts.angry.obj.el);
        /* 右眉に連動させる*/

        this.parts.eyeBrowRight.obj.effect = this.parts.angry.obj;
      }
      /* 呼び出し時に指定されたエレメントに顔パーツ追加*/

      this.el.appendChild(this.outline);
      /* 状態変更中カウント*/

      this.moving = 0;
    }

    /**
    * 現在の各パーツの状態位置取得
    *
    * @return { パーツ名: 状態位置 }の連想配列
    */


    FaceEmotion.prototype.state = function() {
      return {
        eyebrow: this.parts.eyeBrowLeft.obj.cur - 100,
        eye: this.parts.eyeLeft.obj.cur - 100,
        mouth: this.parts.mouth.obj.cur - 100
      };
    };

    /**
    * 指定したパーツの状態位置変更
    *
    * @param name パーツ名もしくは{ パーツ名: 状態位置 }の連想配列
    * @param value nameにパーツ名を指定した場合は状態位置、nameに連想配列を指定した場合はオプションがずれて入る
    * @param options オプション
    */


    FaceEmotion.prototype.set = function(name, value, options) {
      var cb, f, funcs, n, p, parts, _i, _len, _ref5, _ref6, _results,
        _this = this;
      if (options == null) {
        options = {};
      }
      /* 現在状態変更中なら中止する*/

      if (this.moving > 0) {
        _ref5 = this.parts;
        for (n in _ref5) {
          p = _ref5[n];
          p.obj.abort();
        }
      }
      /* 状態変更設定とオプション取得(引数に渡されたパターンにより変化)*/

      parts = {};
      if (typeof name === 'string') {
        parts[name] = value;
      } else {
        options = value != null ? value : {};
        parts = name;
      }
      /* オプションデフォルト値*/

      if (options.speed == null) {
        options.speed = 10;
      }
      options.speed = Number(options.speed);
      if (options.animate == null) {
        options.animate = true;
      }
      /* 変更させるパーツを判別して実行用配列にセット*/

      funcs = [];
      for (name in parts) {
        value = parts[name];
        _ref6 = this.parts;
        for (n in _ref6) {
          p = _ref6[n];
          if (p.key != null) {
            if (p.key === name) {
              funcs.push({
                parts: n,
                value: value
              });
            }
          }
        }
      }
      /* 状態変更実行*/

      this.moving = funcs.length;
      cb = function() {
        if (--_this.moving === 0) {
          return typeof options.complete === "function" ? options.complete() : void 0;
        }
      };
      _results = [];
      for (_i = 0, _len = funcs.length; _i < _len; _i++) {
        f = funcs[_i];
        _results.push(this.parts[f.parts].obj.set(f.value, options, cb));
      }
      return _results;
    };

    return FaceEmotion;

  })();

  this.FaceEmotion = FaceEmotion;

}).call(this);
